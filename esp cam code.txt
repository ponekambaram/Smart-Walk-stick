/******************************************************
 * ESP32-CAM + SD + TensorFlowLite (Chirale v2.0.0)
 * 3-Class Terrain Model (INT8)
 * Classes: pit, road, stairs
 * Rejects unknown images (confidence < 75%)
 ******************************************************/

#include <Arduino.h>
#include <FS.h>
#include <SD_MMC.h>
#include "esp_camera.h"

// ===== TensorFlow Lite Micro (Chirale) =====
#include <Chirale_TensorFlowLite.h>
#include "tensorflow/lite/schema/schema_generated.h"
#include "tensorflow/lite/micro/micro_interpreter.h"
#include "tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "tensorflow/lite/micro/micro_error_reporter.h"
#include "tensorflow/lite/c/common.h"

// ===== Camera Pins (AI Thinker ESP32-CAM) =====
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ===== TensorFlow Memory =====
#define TENSOR_ARENA_SIZE (60 * 1024)
uint8_t *tensor_arena;

tflite::MicroErrorReporter micro_error_reporter;
const tflite::Model *model = nullptr;
tflite::MicroInterpreter *interpreter = nullptr;

TfLiteTensor *input = nullptr;
TfLiteTensor *output = nullptr;

tflite::MicroMutableOpResolver<10> resolver;

// ===== Class Names =====
const char *labels[3] = {
  "pit",
  "road",
  "stairs"
};

// ===== Confidence threshold =====
#define CONFIDENCE_THRESHOLD 0.75f

// ================= CAMERA =================
void setupCamera() {
  camera_config_t config;

  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer   = LEDC_TIMER_0;

  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;

  config.pin_xclk  = XCLK_GPIO_NUM;
  config.pin_pclk  = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href  = HREF_GPIO_NUM;

  config.pin_sscb_sda = SIOD_GPIO_NUM;
  config.pin_sscb_scl = SIOC_GPIO_NUM;

  config.pin_pwdn  = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;

  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_RGB565;
  config.frame_size   = FRAMESIZE_QQVGA;  // 160x120
  config.jpeg_quality = 12;
  config.fb_count     = 1;

  if (esp_camera_init(&config) != ESP_OK) {
    Serial.println("âŒ Camera init failed!");
    while (true);
  }

  Serial.println("âœ… Camera OK");
}

// ================= LOAD MODEL =================
void loadModel() {
  Serial.println("ðŸ”¹ Mounting SD...");

  if (!SD_MMC.begin()) {
    Serial.println("âŒ SD mount failed");
    while (true);
  }

  File f = SD_MMC.open("/terrain_model.tflite");
  if (!f) {
    Serial.println("âŒ terrain_model.tflite not found");
    while (true);
  }

  size_t size = f.size();
  Serial.printf("ðŸ“¦ Model size: %d bytes\n", size);

  uint8_t *modelData = (uint8_t *)ps_malloc(size);
  f.read(modelData, size);
  f.close();

  model = tflite::GetModel(modelData);

  if (model->version() != TFLITE_SCHEMA_VERSION) {
    Serial.println("âŒ Schema mismatch");
    while (true);
  }

  resolver.AddConv2D();
  resolver.AddDepthwiseConv2D();
  resolver.AddFullyConnected();
  resolver.AddMaxPool2D();
  resolver.AddReshape();
  resolver.AddQuantize();
  resolver.AddDequantize();
  resolver.AddSoftmax();
  resolver.AddRelu();

  tensor_arena = (uint8_t *)ps_malloc(TENSOR_ARENA_SIZE);

  interpreter = new tflite::MicroInterpreter(
    model,
    resolver,
    tensor_arena,
    TENSOR_ARENA_SIZE
  );

  if (interpreter->AllocateTensors() != kTfLiteOk) {
    Serial.println("âŒ Tensor alloc failed");
    while (true);
  }

  input = interpreter->input(0);
  output = interpreter->output(0);

  Serial.println("âœ… Model Loaded");
}

// ================= SOFTMAX =================
void softmax(const int8_t *in, float *out, int len) {
  float maxVal = in[0];
  for (int i = 1; i < len; i++)
    if (in[i] > maxVal) maxVal = in[i];

  float sum = 0;
  for (int i = 0; i < len; i++) {
    out[i] = exp((in[i] - maxVal) / 10.0f);
    sum += out[i];
  }
  for (int i = 0; i < len; i++) out[i] /= sum;
}

// ================= SETUP =================
void setup() {
  Serial.begin(115200);
  delay(500);

  setupCamera();
  loadModel();

  Serial.println("ðŸš€ Ready for inference!");
}

// ================= LOOP =================
void loop() {

  camera_fb_t *fb = esp_camera_fb_get();
  if (!fb) return;

  int idx = 0;
  int srcW = 160, srcH = 120;
  int dstW = 64, dstH = 64;

  int scaleX = srcW / dstW;
  int scaleY = srcH / dstH;

  for (int y = 0; y < dstH; y++) {
    for (int x = 0; x < dstW; x++) {

      int sx = x * scaleX;
      int sy = y * scaleY;
      int si = (sy * srcW + sx) * 2;

      uint16_t pix = (fb->buf[si] << 8) | fb->buf[si + 1];

      uint8_t r = ((pix >> 11) & 0x1F) << 3;
      uint8_t g = ((pix >> 5) & 0x3F) << 2;
      uint8_t b = (pix & 0x1F) << 3;

      input->data.int8[idx++] = r - 128;
      input->data.int8[idx++] = g - 128;
      input->data.int8[idx++] = b - 128;
    }
  }

  esp_camera_fb_return(fb);

  interpreter->Invoke();

  float probs[3];
  softmax(output->data.int8, probs, 3);

  int best = 0;
  float maxP = probs[0];

  for (int i = 1; i < 3; i++) {
    if (probs[i] > maxP) {
      maxP = probs[i];
      best = i;
    }
  }

  if (maxP >= CONFIDENCE_THRESHOLD) {
    Serial.printf("ðŸŽ¯ DETECTED: %s (%.1f%%)\n", labels[best], maxP * 100);
  } else {
    Serial.println("âš  Unknown object â€” Not matching dataset");
  }

  delay(500);
}
